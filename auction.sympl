# """Auction 2.0.0
# A sample smart contract to represent auctions and associated bids. This is a very naive implementation of a smart
# contract with the intention to be used to get to grips with the tooling surrounding smart contract authoring in the
# Symbiont Assembly SDK
#
### Channel Topology
# - Public channel
# - Silent channels
#   + Any Admin can create a "silent auction," invite-only private channels with masked event outputs.
#
### Roles
# - Admin
# - Auction creator
# - Silent channel member
#
### Actions
# | Action            | Channel         | Role                       |
# |-------------------|-----------------|----------------------------|
# | Create Auction    | Public / Silent | Any / Admin                |
# | Make Bid          | Public / Silent | Any / Silent Member        |
# | Close Auction     | Public / Silent | Auction Creator            |
# | Create Admin      | Public          | First time Any, then Admin |
# | Add Silent Member | Public          | Admin + Silent Member      |
# """

#################
# Public Models #
#################

# A bid on an auction.
schema Bid:
    bidder: str
    amount: int

# An auction. Tracks the creator, product and bidder info, and whether or not it's still open for bidding.
schema Auction:
    id: str
    product_description: str
    initial_price: int
    last_bid: Optional[Bid]
    creator: str
    closed: bool
    channel: ChannelName

# Admins are the only users allowed to:
# 1. Create the Silent auction channel
# 2. Select another admin to replace themselves (one serving admin at a time)
# 3. Add/remove members in the Silent channel
# The very first time a user is chosen to be an admin, that permission is given automatically.
schema Admin:
    id: KeyAlias

###################################
# Auction API and Implementations #
###################################

# FOR TESTING ONLY
@clientside
def get_admins() -> List[Admin]:
    return cvm.storage.query(AdminStatic).values()

# Returns all auctions in storage.
@clientside
def get_auctions() -> List[Auction]:
    return cvm.storage.query(AuctionStatic).values()

# Returns a specific auction (if it exists).
@helper
def get_auction(id: Identifier) -> Optional[Auction]:
    return cvm.storage.query(AuctionStatic).where('id', id).values()[0]

# Creates an auction.
# Defaults to the PUBLIC channel, but members of the silent channel may post to it by specifying its ChannelName.
@clientside
def create_auction(product_description: str, initial_price: int, silent: bool=False) -> None:
    channel : ChannelName = PUBLIC
    if silent:
        if not is_admin():
            cvm.error(f"Only an admin may perform this function.")
        channel = cvm.new_channel('SLN')

    with PostTxArgs(channel):
        _create_auction(product_description, initial_price)

@executable
def _create_auction(product_description: str, initial_price: int) -> None:
    id = cvm.generate_id('AUC')
    creator : str = cvm.tx.key_alias
    channel : ChannelName = cvm.tx.write_channel

    new_auction = Auction(id = id,
                          product_description = product_description,
                          initial_price = initial_price,
                          last_bid = None,
                          creator = creator,
                          closed = False,
                          channel = channel)
    cvm.storage.put(id, new_auction)

    c_str : str = channel
    if c_str == 'PUBLIC':
        cvm.create_event('Created Auction', std.json(new_auction))
    else:
        cvm.create_event('Created Auction', {"channel": channel, "notice": "Silent auction created."})

# Closes a specific auction.
# This function can only be successfully executed by its creator, identified by the invoking key alias.
# The winning bid will get returned upon the closing of the auction.
@clientside
def close_auction(id: Identifier) -> Optional[Bid]:
    auction = get_auction(id)
    actor : str = cvm.tx.key_alias

    if isinstance(auction, None):
        cvm.error(f"You do not have access to auction {id}.")
    if auction.creator != actor:
        cvm.error(f"User {actor} not the creator of the auction.")
    if auction.closed:
        cvm.error(f"Auction {id} is already closed.")

    channel = auction.channel
    with PostTxArgs(channel):
        _close_auction(id)

@executable
def _close_auction(id: Identifier) -> None:
    actor : str = cvm.tx.key_alias
    channel : ChannelName = cvm.tx.write_channel
    auction = cvm.storage.get(channel, AuctionStatic, id)

    if isinstance(auction, None):
        cvm.error(f"You do not have access to auction {id}.")
    if actor != auction.creator:
        cvm.error(f"User {actor} not the creator of the auction.")
    if auction.closed:
        cvm.error(f"Auction {id} is already closed.")

    auction.closed = True
    cvm.storage.put(id, auction)
    last_bid = auction.last_bid

    c_str : str = channel
    if c_str == 'PUBLIC':
        cvm.create_event('Closed Auction', std.json(auction))
    else:
        cvm.create_event('Closed Auction', {"channel": channel, "notice": "Silent auction closed."})


###############################
# Bid API and Implementations #
###############################

# Places a bid on a product, identified by the auction ID.
@clientside
def bid(id: Identifier, amount: int) -> None:
    auction = get_auction(id)
    if isinstance(auction, None):
        cvm.error(f"You do not have access to auction {id}.")
    if auction.closed:
        cvm.error(f"Auction {id} is closed.")

    last_bid = auction.last_bid
    if isinstance(last_bid, None):
        if amount < auction.initial_price:
            cvm.error(f"The bid amount must be larger than initial price ${auction.initial_price}.")
    else:
        if amount <= last_bid.amount:
            cvm.error(f"The bid amount must be larger than current bid amount ${last_bid.amount}.")

    channel = auction.channel
    with PostTxArgs(channel):
        _bid(id, amount)

@executable
def _bid(id: Identifier, amount: int) -> None:
    auction = get_auction(id)
    bidder: str = cvm.tx.key_alias
    channel : ChannelName = cvm.tx.write_channel

    if isinstance(auction, None):
        cvm.error(f"You do not have access to auction {id}.")
    if auction.closed:
        cvm.error(f"Auction {id} is closed.")
    
    last_bid = auction.last_bid
    if isinstance(last_bid, None):
        if amount < auction.initial_price:
            cvm.error(f"The bid amount must be larger than initial price ${auction.initial_price}.")
    else:
        if amount <= last_bid.amount:
            cvm.error(f"The bid amount must be larger than current bid amount ${last_bid.amount}.")

    bid = Bid(bidder = bidder, amount = amount)
    auction.last_bid = bid
    cvm.storage.put(id, auction)

    c_str : str = channel
    if c_str == 'PUBLIC':
        cvm.create_event('Bid Placed', std.json(auction))
    else:
        cvm.create_event('Bid Placed', {"channel": channel, "notice": "Bid placed on silent auction."})


#################################
# Admin API and Implementations #
#################################

# Creates an admin.
@clientside
def create_admin(new_admin: KeyAlias) -> None:
    existing_admins = cvm.storage.query(AdminStatic).values()

    # The first admin creation happens automatically.
    # Anyone created beyond that must be created by an Admin and shouldn't be an Admin themselves already.
    if len(existing_admins) > 0:
        if not is_admin():
            cvm.error(f"Only an admin may perform this function.")
            
        na_ka : str = new_admin
        for a in existing_admins:
            a_ka : str = a.id
            if a_ka == na_ka:
                cvm.error(f"{new_admin} is already an admin.")

    with PostTxArgs(PUBLIC):
        _create_admin(new_admin)

@executable
def _create_admin(new_admin: KeyAlias) -> None:
    existing_admins = cvm.storage.query(AdminStatic).values()

    if len(existing_admins) > 0:
        if not is_admin():
            cvm.error(f"Only an admin may perform this function.")

        na_ka : str = new_admin
        for a in existing_admins:
            a_ka : str = a.id
            if a_ka == na_ka:
                cvm.error(f"{new_admin} is already an admin.")

    admin = Admin(id=new_admin)
    cvm.storage.put(cvm.generate_id('ADM'), admin)
    cvm.create_event('Admin Created', std.json(admin))

# Checks if the transaction signer is the admin.
@helper
def is_admin() -> bool:
    tx_ka : str = cvm.tx.key_alias
    existing_admins = cvm.storage.query(AdminStatic).values()

    for a in existing_admins:
        a_ka : str = a.id
        if a_ka == tx_ka:
            return True
    return False


#############################################
# Add/Remove Member API and Implementations #
#############################################

# Adds a member to a silent auction channel, giving them access to bid there.
@clientside
def add_member(new_member: KeyAlias, id: Identifier) -> None:
    if not is_admin():
        cvm.error(f"Only an admin may perform this function.")

    auction = get_auction(id)
    if isinstance(auction, None):
        cvm.error(f"You do not have access to auction {id}.")
    if auction.closed:
        cvm.error(f"Auction {id} is closed.")
    
    tx_ka : str = cvm.tx.key_alias
    if tx_ka != auction.creator:
        cvm.error(f"Only the auction creator may add members to the silent auction.")

    channel = auction.channel
    with PostTxArgs(channel, [PUBLIC]):
        _add_member(new_member, id)
    
@executable
def _add_member(new_member : KeyAlias, id: Identifier) -> None:
    if not is_admin():
        cvm.error(f"Only an admin may perform this function.")

    auction = get_auction(id)
    if isinstance(auction, None):
        cvm.error(f"Auction does not exist.")
    if auction.closed:
        cvm.error(f"Auction {id} is closed.")

    tx_ka : str = cvm.tx.key_alias
    if tx_ka != auction.creator:
        cvm.error(f"Only the auction creator may add members to the silent auction.")

    channel = cvm.tx.write_channel
    cvm.send_key(channel, new_member)
    cvm.create_event('Member Added', {"channel": channel, "notice": "Member added to silent auction."})
